### [전체 목차](../../README.md)
### [이전 페이지](../README.md)

# 3 일차
함수 


## 목차

- [Positional/Keyword argument](#positionalkeyword-argument)
- [가변인자 파라미터](#가변인자-파라미터)
- [변수의 유효범위](#변수의-유효범위)
- [람다 표현식](#람다-표현식)
- [iterable 및 함수를 매개변수로 받는 함수](#iterable-및-함수를-매개변수로-받는-함수)

## [Positional/Keyword argument](#목차)
- Argument: 함수/메소드를 호출할 때 전달하는 입력 값
- Parameter: 그 값을 저장하는 변수
- Positional argument
    -  함수 호출 할때 argument를 Parameter 순서에 맞춰 값을 넣어서 호출
- keyword  argument 
    - 함수 호출할 때 argument를 `Parameter 변수명 = 전달할 값` 형식으로 선언
    - 순서와 상관없이 호출

```py
# positional argument: 파라미터 변수 순서에 맞춰 값을 전달
print_info3("이순신", 30, "서울", "독서")

# keyword argument: 파라미터 변수명 = 전달할 값
print_info3(name="강감찬", age=20, address="인천", hobby="게임")

# positional argument를 먼저 넣고 그 다음에 keyword argument을 넣어 호출
print_info3("강감찬", 30, address="인천", hobby="스포츠")
```

```py
# default(기본값)이 있는 파라미터가 많이 있는 함수
def test(a=0, b=0, c=None, d=-1, e=0, f=None, g=None):
    print(a,b,c,d,e,f,g)

test()
> 0 0 None -1 0 None None

test(100, 200)
> 100 200 None -1 0 None None

test(g=1000)
> 0 0 None -1 0 None 1000
```

## [가변인자 파라미터](#목차)
- **tuple이나 dictionary로 묶어서** 받을 수있도록 선언하는 parameter
- **\*변수명**: **positional argument**를 개수와 상관없이 하나의 변수로 받을 수 있도록 선언
    - 전달된 값들은 tuple로 받아서 처리한다.
    - 관례적으로 변수명은 \*args를 사용한다.
- **\*\*변수명**: **keyword argument**를 개수와 상관없이 하나의 변수로 받을 수 있도록 선언
    - 전달된 값들은 dictionary로 받아서 처리한다.
    - 관례적으로 변수명은 \*\*kwargs 를 사용한다.
- 하나의 함수에 가변인자는 \* 하나, \*\* 두개짜리 각각 한개씩만 선언할 수 있다.
- 파라미터 선언순서
    1. 기본값이 없는 파라미터
    2. 기본값이 있는 파라미터
    3. `*args`
    4. `**kwargs`

```py
def summation_var_args(*nums):
    print(type(nums))
    value = 0
    for v in nums:
        value += v
    return value

r = summation_var_args(1, 2)
print(r)
> <class 'tuple'>
> 3
```

```py
def print_info(**info):
    print(type(info))
    print(info)

print_info(name="홍길동", address="서울", age=40)
> <class 'dict'>
> {'name': '홍길동', 'address': '서울', 'age': 40}
```

```py
# 파라미터 선언 순서
def test(n1, n2, n3=100, *args, **kwargs):
    print(n1,n2,n3)
    print(args)
    print(kwargs)

test(1,2,3, 4,5, a=1, b=2)
> 1 2 3
> (4, 5)
> {'a': 1, 'b': 2}
```

```py
def test2(*args):
    print(args, len(args))
l = [1,2,3,4]
test2(*l) # l(리스트/튜플)의 원소들을 가변인자에 전달

def test3(**kwargs):
    print(kwargs)
d = {"name":"홍길동", "age":30}
test3(**d) # d(딕셔너리)의 item들을 가변인자에 전달
```

## [변수의 유효범위](#목차)

- **지역변수 (local variable)**
    - 함수 안에 선언된 변수
    - 선언된 그 함수 안에서만 사용할 수 있다.
- **전역변수 (global variable)**
    - 함수 밖에 선언된 변수
    - 모든 함수들이 공통적으로 사용할 수 있다.
    - 함수 내에서 전역변수에 값을 대입하기 위해서는 global 키워드를 이용
        - global로 선언하지 않으면 그 변수와 동일한 지역변수을 생성한다.
        - 함수에서 변수를 조회할 경우 **먼저 지역변수를 찾고 없으면 전역변수를 찾는다.**

```py
# 전역변수(global variable)
value1 = 100
value2 = 2000

def fun2():
    print(value1, value2)

print(value1, value2)
fun2()
> 100 2000
> 100 2000
```

```py
# 전역변수 value3
value3 = 1000

def fun4():
    # 함수 안에서 변수 => 지역변수 (이름이 전역변수와 같은 지역변수)
    global value3 # value3 변수를 전역변수 선언. (전역변수 값을 변경)
    value3 = 5000
    print(value3)
fun4()
> 5000

value3
> 5000
```

## [람다 표현식](#목차)
- 함수를 하나의 식을 이용해서 정의할 때 사용하는 표현식
- 값을 입력받아서 **처리 결과**를 반환하는 간단한 함수를 표현식으로 정의할 수 있다.

```python
lambda 매개변수[, 매개변수, ...] : 명령문(구문)
```
- 명령문은 하나의 실행문만 가능하다.
- 명령문이 처리한 결과를 리턴해준다.
- **람다식은 함수의 매개변수로 함수를 전달하는 일회성 함수를 만들때 주로 사용한다.**

```py
a = lambda num1, num2: num1 + num2
a(10, 20)
> 30

# 여러 개의 처리를 할 경우, 자료구조로 묶어준다.
# 튜플로 묶을 때는 ()를 반드시 사용
lambda x,y: [x+y, x-y, x*y, x/y]
```

## [iterable 및 함수를 매개변수로 받는 함수](#목차)
- sorted(iterable, reverse=False, key=None)
    - Parameter로 iterable의 각 원소를 받는 함수  
    - 이 함수가 반환하는 값을 기준으로 정렬  
- filter(함수, Iterable)
    - Iterable의 원소들 중에서 특정 조건을 만족하는 원소들만 걸러주는 함수
    - 원소 하나 하나를 함수에 전달해 True를 반환하는 것만 반환
- map(함수, Iterable)
    - Iterable의 원소들 하나 하나를 처리해서 그 결과를 반환
- **filter/map 반환타입**: generator가 반환 된다.

```py
# 특수문자 < 숫자 < 대문자 < 소문자 < 한글
lst = ["a","abc","k","Zz","abcde","rs","12345","안녕하세요."]
lst.sort(reverse=True) # 리스트 자체를 정렬
lst
> ['안녕하세요.', 'rs', 'k', 'abcde', 'abc', 'a', 'Zz', '12345']

sorted(lst, reverse=True)
# 모든 자료구조를 정렬해서 새로운 리스트에 담아준다.
> ['안녕하세요.', 'rs', 'k', 'abcde', 'abc', 'a', 'Zz', '12345']

def countChar(txt):
    return len(txt)

[countChar(t) for t in lst]
> [6, 2, 1, 5, 3, 1, 2, 5]

# 각 원소를 key 함수에 전달해서 리턴되는 값을 기준으로 정렬
sorted(lst, key=countChar)
> ['k', 'a', 'rs', 'Zz', 'abc', 'abcde', '12345', '안녕하세요.']

sorted(lst, key=lambda x: len(x), reverse=True)
> ['안녕하세요.', 'abcde', '12345', 'abc', 'rs', 'Zz', 'k', 'a']
```

```py
lst2 = [1,10,-2,13,26,27,-101,17]
# 홀수
[v for v in lst2 if v % 2 != 0]
> [1, 13, 27, -101, 17]

# filter(함수-filter 조건, 자료구조)
# x: 원소 하나를 받을 변수. bool 리턴
list(filter(lambda x: x%2 != 0, lst2))
> [1, 13, 27, -101, 17]
```

```py
# map(함수-처리방식, 자료구조)
# 원소들을 일괄처리
# 함수 -> 원소 하나를 받아서 처리 결과를 리턴
list(map(lambda x: x*-1, lst2))
> [-1, -10, 2, -13, -26, -27, 101, -17]
```

### [목차로 돌아가기](#목차)
## [이전 페이지](../README.md)
