### [전체 목차](../../README.md)
### [이전 페이지](../README.md)

# 3 일차
클래스 

`객체지향 프로그래밍`
> 변수와 함수들 간 서로 연관성 있는 것끼리 묶어 모듈화 하는 개발 언어

절차지향은 유지보수가 어렵다. (중간에 코드 수정은 위험)

개발 단계: 분석 -> 설계 -> 구현 -> 테스트 -> 완성  
유지 보수: 오류, 기능 추가/변경/삭제

`객체 안의 함수: 메소드`

## 목차

- [Instance & Class](#instance--class)
- [Attribute & Method](#attribute--method)
- [정보 은닉](#정보-은닉)

## [Instance & Class](#목차)

### Instance(객체)
- 연관성 있는 값들과 그 값들을 처리하는 함수(메소드)들의 묶음
- 속성(Attribute)
    - 객체의 데이터/상태로 객체를 구성하는 값들
- 메소드(method)
    - 객체가 제공하는 기능으로 주로 Attribute들을 처리한다.

### Class(클래스)
- 객체(instance)의 설계도
    - 동일한 형태의 객체들이 가져야 하는 Attribute와 Method들을 정의한 것
        - 클래스를 정의할 때 어떤 속성과 메소드를 가지는지 먼저 설계해야 한다.
    - 클래스로부터 객체(instance)를 생성한 뒤 사용한다.
        - 변수 = 클래스이름()
    - 클래스는 데이터 타입, instance(겍체)는 값

```python
class 클래스이름:  # 선언부
    # 클래스 구현
    # 메소드들을 정의
```

- **클래스 이름의 관례**
    - **파스칼 표기법** 사용
    - ex) Person, Student, HighSchoolStudent

```python
class User:
    pass
User() # Instance 생성

u1 = User() # 다른 클래스
u2 = User()
u3 = User()

# instance에 속성을 추가
# instance의 상태/데이터
u1.name = "홍길동" # 객체.변수명 = 값
u1.age = 30
u1.address = "서울"
```

User 클래스로부터 u1 객체 생성  
name, age, address가 저장된 영역을 묶어서 u1에서 관리

```py
u2.name = "이순신"
u3.age = 20
u3.이름 = "이름" # 이런 경우 발생 -> 초기화(Initialize)
print(u1.name, u2.name)
> 홍길동 이순신
```

```py
# Initialize를 이용해서 객체의 속성을 초기화 하는 클래스
class User2:
    
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
        self.address = "서울"     
# self(객체)에 할당

# 클래스이름() -> instance 생성 => initializer를 호출해서 객체를 생성  
# User2()는 __init__ 메소드를 호출
```
객체 생성  
1. 메모리에 instance(객체) 생성  
2. `__init__()` 메소드 호출  
    - 1에서 생성된 instance를 `__init__()` 메소드의 첫번째 파라미터에 전달
3. self 파라미터(영역)에 메모리 상 생성된 객체 할당
4. name 영역에 "이순신" 할당
 
```
self.name -> self 안에 name 생성
name(지역변수) 안 "이순신" -> self 안 name으로 이동
age(지역변수)의 30이 self 안 age로 이동
객체 생성 후 지역변수는 사라짐
```

```py
u1 = User2('이순신', 30, 'lee@a.com')
print(u1.name, u1.age, u1.email, u1.address)
> 이순신 30 lee@a.com 서울

u1.name = "강감찬"
u1.name
> '강감찬'

u2 = User2("유관순", 40, "yoo@a.com")
u1.blood_type = "B형" # 추가보단 속성 값을 변경할 때 사용
print(u1.blood_type)
# u1과 u2가 가진 변수들이 달라짐 -> 초기화가 있는 이유
> B형
```

## [Attribute & Method](#목차)

### Attribute
- 객체의 데이터, 객체가 가지는 값, 객체의 상태

### 객체에 속성을 추가, 조회
- 객체의 속성 추가(값 변경)
    1. Initializer(생성자)를 통한 추가 -> 초기화(처음 추가)할 때
    2. 객체.속성명 = 값 (속성값 추가/변경)
    3. 메소드 사용 (속성값 추가/변경)

- 속성 값 조회
    - `객체.속성명`

- `객체.___dict__`
    - 객체가 가지고 있는 Attribute들을 dictionary로 반환한다.

```py
u1.__dict__

> {'name': '강감찬',
> 'age': 30,
> 'email': 'lee@a.com',
> 'address': '서울',
> 'blood_type': 'B형'}
```

### Instance 메소드
- 객체가 제공하는 기능
- 객체의 attribute 값을 처리하는 기능을 구현한다.

```python
def 이름(self [, 매개변수들 선언]):
    # 구현
    # attribute 사용(조회/대입)
    self.attribute 
```

- **메소드 호출**
    - `객체.메소드이름([argument, ...])`

```py
class User3:
    
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
        self.address = "서울"

    # 메소드
    def add_age(self, age):
        # 기존 나이에 받은 나이를 더해준다.
        self.age = self.age + age # self.age: attribute 변수, age: local 변수

    def get_user_info(self):
        # User의 정보를 하나의 문자열로 만들어서 변환
        return f"이름: {self.name}, 나이: {self.age}, Email: {self.email}, 주소: {self.address}"

    def get_city_type(self):
        result = None
        if self.address == "서울":
            result = "특별시"
        elif self.address in ["부산","인천","대구","광주","울산","대전"]:
            result = "광역시"
        else:
            result = "일반시"
        return result
```

```py
u1 = User3("이순신",30,"lee@a.com")
u1_info = u1.get_user_info()
print(u1_info)

> 이름: 이순신, 나이: 30, Email: lee@a.com, 주소: 서울
```

u1은 전역변수(global)  
User3 내 self.name 등은 instance 변수  
u1에는 name 등의 메모리 상 주소(self.name 위치)가 들어감  
u1.user_name은 class에 없는 변수
u1.user_name = "aaa"을 하면 class에 없는 변수를 갖게 되어 안좋음
u1.add_age(2) # add_age(self, age) -> self에는 u1, age에는 2
print(u1.age)
city_type = u1.get_city_type()
print(city_type)
u1.address = "울산"
print(u1.get_city_type())

u1.address = "구미"
print(u1.get_city_type())


## [정보 은닉](#목차)
- Attribute의 값을 caller(객체 외부)가 마음대로 바꾸지 못하게 하기 위해 직접 호출을 막고 setter/getter 메소드를 통해 값을 변경/조회 하도록 한다.
    - Attribute의 값을 업무 규칙/조건에 맞는 값만 대입할 수 있도록 하는 것이 목적.
        - Attribute의 값을 변경하는 메소드에 변경 가능 조건을 넣어 업무 규칙에 맞는 값들만 대입될 수 있도록 한다.
    - **setter**
        - Attribute의 값을 변경하는 메소드. 관례상 set 으로 시작
    - **getter**
        - Attribute의 값을 조회하는 메소드. 관례상 get 으로 시작
- Attribute 직접 호출 막기
    - Attribute의 이름을 \_\_(double underscore)로 시작한다. (\_\_로 끝나면 안된다.)
    - 같은 클래스에서는 선언한 이름으로 사용가능하지만 외부에서는 그 이름으로 호출할 수 없게 된다.
    



### [목차로 돌아가기](#목차)
## [이전 페이지](../README.md)
