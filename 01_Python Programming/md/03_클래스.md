### [전체 목차](../../README.md)
### [이전 페이지](../README.md)

# 3 일차
클래스 

`객체지향 프로그래밍`
> 변수와 함수들 간 서로 연관성 있는 것끼리 묶어 모듈화 하는 개발 언어

절차지향은 유지보수가 어렵다. (중간에 코드 수정은 위험)

개발 단계: 분석 -> 설계 -> 구현 -> 테스트 -> 완성  
유지 보수: 오류, 기능 추가/변경/삭제

`객체 안의 함수: 메소드`

## 목차

- [Instance & Class](#instance--class)
- [Attribute & Method](#attribute--method)
- [정보 은닉](#정보-은닉)
- [데코레이터](#데코레이터)
- [상속](#상속)
- [메소드 재정의](#메소드-재정의)
- [특수 메소드](#특수-메소드)

## [Instance & Class](#목차)

### Instance(객체)
- 연관성 있는 값들과 그 값들을 처리하는 함수(메소드)들의 묶음
- 속성(Attribute)
    - 객체의 데이터/상태로 객체를 구성하는 값들
- 메소드(method)
    - 객체가 제공하는 기능으로 주로 Attribute들을 처리한다.

### Class(클래스)
- 객체(instance)의 설계도
    - 동일한 형태의 객체들이 가져야 하는 Attribute와 Method들을 정의한 것
        - 클래스를 정의할 때 어떤 속성과 메소드를 가지는지 먼저 설계해야 한다.
    - 클래스로부터 객체(instance)를 생성한 뒤 사용한다.
        - 변수 = 클래스이름()
    - 클래스는 데이터 타입, instance(겍체)는 값

```python
class 클래스이름:  # 선언부
    # 클래스 구현
    # 메소드들을 정의
```

- **클래스 이름의 관례**
    - **파스칼 표기법** 사용
    - ex) Person, Student, HighSchoolStudent

```python
class User:
    pass
User() # Instance 생성

u1 = User() # 다른 클래스
u2 = User()
u3 = User()

# instance에 속성을 추가
# instance의 상태/데이터
u1.name = "홍길동" # 객체.변수명 = 값
u1.age = 30
u1.address = "서울"
```

User 클래스로부터 u1 객체 생성  
name, age, address가 저장된 영역을 묶어서 u1에서 관리

```py
u2.name = "이순신"
u3.age = 20
u3.이름 = "이름" # 이런 경우 발생 -> 초기화(Initialize)
print(u1.name, u2.name)
> 홍길동 이순신
```

```py
# Initialize를 이용해서 객체의 속성을 초기화 하는 클래스
class User2:
    
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
        self.address = "서울"     
# self(객체)에 할당

# 클래스이름() -> instance 생성 => initializer를 호출해서 객체를 생성  
# User2()는 __init__ 메소드를 호출
```
객체 생성  
1. 메모리에 instance(객체) 생성  
2. `__init__()` 메소드 호출  
    - 1에서 생성된 instance를 `__init__()` 메소드의 첫번째 파라미터에 전달
3. self 파라미터(영역)에 메모리 상 생성된 객체 할당
4. name 영역에 "이순신" 할당
 
```
self.name -> self 안에 name 생성
name(지역변수) 안 "이순신" -> self 안 name으로 이동
age(지역변수)의 30이 self 안 age로 이동
객체 생성 후 지역변수는 사라짐
```

```py
u1 = User2('이순신', 30, 'lee@a.com')
print(u1.name, u1.age, u1.email, u1.address)
> 이순신 30 lee@a.com 서울

u1.name = "강감찬"
u1.name
> '강감찬'

u2 = User2("유관순", 40, "yoo@a.com")
u1.blood_type = "B형" # 추가보단 속성 값을 변경할 때 사용
print(u1.blood_type)
# u1과 u2가 가진 변수들이 달라짐 -> 초기화가 있는 이유
> B형
```

## [Attribute & Method](#목차)

### Attribute
- 객체의 데이터, 객체가 가지는 값, 객체의 상태

### 객체에 속성을 추가, 조회
- 객체의 속성 추가(값 변경)
    1. Initializer(생성자)를 통한 추가 -> 초기화(처음 추가)할 때
    2. 객체.속성명 = 값 (속성값 추가/변경)
    3. 메소드 사용 (속성값 추가/변경)

- 속성 값 조회
    - `객체.속성명`

- `객체.___dict__`
    - 객체가 가지고 있는 Attribute들을 dictionary로 반환한다.

```py
u1.__dict__

> {'name': '강감찬',
> 'age': 30,
> 'email': 'lee@a.com',
> 'address': '서울',
> 'blood_type': 'B형'}
```

### Instance 메소드
- 객체가 제공하는 기능
- 객체의 attribute 값을 처리하는 기능을 구현한다.

```python
def 이름(self [, 매개변수들 선언]):
    # 구현
    # attribute 사용(조회/대입)
    self.attribute 
```

- **메소드 호출**
    - `객체.메소드이름([argument, ...])`

```py
class User3:
    
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
        self.address = "서울"

    # 메소드
    def add_age(self, age):
        # 기존 나이에 받은 나이를 더해준다.
        self.age = self.age + age # self.age: attribute 변수, age: local 변수

    def get_user_info(self):
        # User의 정보를 하나의 문자열로 만들어서 변환
        return f"이름: {self.name}, 나이: {self.age}, Email: {self.email}, 주소: {self.address}"

    def get_city_type(self):
        result = None
        if self.address == "서울":
            result = "특별시"
        elif self.address in ["부산","인천","대구","광주","울산","대전"]:
            result = "광역시"
        else:
            result = "일반시"
        return result
```

```py
u1 = User3("이순신",30,"lee@a.com")
u1_info = u1.get_user_info()
print(u1_info)

> 이름: 이순신, 나이: 30, Email: lee@a.com, 주소: 서울
```

u1: 전역변수(global)  
User3 내 self.name, self.age, ...: instance 변수  
u1에는 name 등의 메모리 상 주소(self.name 위치)가 들어감  

*u1.user_name -> class에 없는 변수*  
*u1.user_name = "aaa"을 하면 class에 없는 변수를 갖게 되어 안 좋음*

```py
u1.add_age(2) # add_age(self, age) -> self에는 u1, age에는 2  
print(u1.age)  
> 32

city_type = u1.get_city_type()  
print(city_type)  
> 특별시

u1.address = "울산"  
print(u1.get_city_type())  
> 광역시

u1.address = "구미"
print(u1.get_city_type())
> 일반시
```


## [정보 은닉](#목차)
- Attribute의 값을 caller(객체 외부)가 바꾸지 못하게 하기 위해 직접 호출을 막는다.
- setter/getter 메소드를 통해 값을 변경/조회 하도록 한다.
    - Attribute의 값을 업무 규칙/조건에 맞는 값만 대입할 수 있도록 한다.
    - **setter**
        - Attribute의 값을 변경하는 메소드. 관례상 set 으로 시작
    - **getter**
        - Attribute의 값을 조회하는 메소드. 관례상 get 으로 시작
- Attribute 직접 호출 막기
    - Attribute의 이름을 \_\_(double underscore)로 시작한다.
    - 같은 클래스에서는 선언한 이름으로 사용가능하다.
    - 외부에서는 그 이름으로 호출할 수 없다.

```py
# 년도, 월, 일 -> 날짜 타입
## 년도: 1 ~ 2030
## 월: 1 ~ 12
## 일: 1 ~ 31

class MyDate:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    def get_date(self):
        return f"{self.year}/{self.month}/{self.day}"
```

```py
today = MyDate(2024, 1, 3)
tomm = MyDate(year=2024, month=1, day=4)

print(today.get_date())
> 2024/1/3

print(today.day, today.year)
> 3 2024

today.day = 50
today.month = "삼월"
print(today.get_date())
> 2024/삼월/50
```

```py
# 위와 같은 값들을 방지하기 위해
class MyDate:
    def __init__(self, year, month, day):
        # attribute 이름.__이름 => class 외부에서 호출할 수 없다. 내부에서만 호출 가능
        # self.__year = year
        # self.__month = month
        # self.__day = day
        self.set_year(year) # 같은 클래스의 instance 메소드 호출 -> self.메소드명()
        self.set_month(month)
        self.set_day(day)

    # attribute들의 값을 변경 메소드 -> setter
    def set_year(self, year): # 규칙이 있는 경우
        if year >= 1 and year <= 2030:
            self.__year = year
        else:
            print("1~2023 사이의 값을 넣으세요.")

    def set_month(self, month):
        if month >= 1 and month <= 12:
            self.__month = month
        else:
            print("1~12 사이의 값을 넣으세요.")

    def set_day(self, day):
        if day >= 1 and day <= 31:
            self.__day = day
        else:
            print("1~31 사이의 값을 넣으세요.")

    # attribute들의 값을 반환(알려주는) 메소드 -> getter
    def get_year(self): # 값을 조회
        return self.__year # __가 있으면 조회가 안됨 -> get 함수 이용

    def get_month(self):
        return self.__month

    def get_day(self):
        return self.__day

    def get_date(self):
        return f"{self.__year}/{self.__month}/{self.__day}"
```

```py
today = MyDate(2024, 1, 3)
tomm = MyDate(year=2024, month=1, day=4)

print(today.get_date())
# print(today.__day, today.__year)
> 2024/1/3

today.__dict__
> {'_MyDate__year': 2024, '_MyDate__month': 1, '_MyDate__day': 3}

today.__day = 50
today.__month = 22
print(today.get_date()) # 값이 바뀌지 않음. __day라는 변수를 새로 생성한 것
> 2024/1/3

print(today.get_day())
> 3

today.set_day(10)
today.set_month(30)
print(today.get_date())
> 1~12 사이의 값을 넣으세요.
> 2024/1/10

today.__dict__
> {'_MyDate__year': 2024,
> '_MyDate__month': 1,
> '_MyDate__day': 10,
> '__day': 50,
> '__month': 22}

today._MyDate__day # 이것은 바뀔 수는 있음
> 10
```

어떤 변수는 self.__year = year (그대로)  
어떤 변수는 self.set_month(month) (메소드)

## [데코레이터](#목차)
- setter/getter 구현 + property()를 이용해 변수 등록
- setter/getter 메소드 이름을 변수처럼 지정
- getter 메소드: @property 데코레이터를 선언  
- setter 메소드: @getter메소드이름.setter 데코레이터를 선언.
    - 반드시 getter 메소드를 먼저 정의한다.
    - setter메소드 이름은 getter와 동일해야 한다.
- getter/setter의 이름을 Attribute 변수처럼 사용한다.
- getter/setter 메소드는 변수 형식으로만 호출 가능하다.

```py
class MyDate2:

    def __init__(self, year, month, day):
        self.year = year # self.year => setter 호출
        self.month = month
        self.day = day

    # attribute들의 값을 반환(알려주는) 메소드 -> getter
    # 메소드 이름 -> 사용할 attribute의 이름으로 지정
    # @property (decorator)를 선언
    
    @property # getter 메소드로 처리
    def year(self):
        return self.__year

    @property
    def month(self):
        return self.__month

    @property
    def day(self):
        return self.__day

    # attribute들의 값을 변경 메소드 -> setter
    # 메소드 이름 -> 사용할 attribute의 이름으로 지정
    # getter이름.setter
    
    @year.setter
    def year(self, year):
        if year >= 1 and year <= 2030:
            self.__year = year
        else:
            print("1~2023 사이의 값을 넣으세요.")
    
    @month.setter
    def month(self, month):
        if month >= 1 and month <= 12:
            self.__month = month
        else:
            print("1~12 사이의 값을 넣으세요.")

    @day.setter
    def day(self, day):
        if day >= 1 and day <= 31:
            self.__day = day
        else:
            print("1~31 사이의 값을 넣으세요.")

    def get_date(self):
        return f"{self.__year}/{self.__month}/{self.__day}"
```

```py
date = MyDate2(2024, 1, 4)  
print(date.get_date())  
> 2024/1/4

date.year = 2020  
date.month = 10  
date.day = 5  
print(date.get_date())
> 2020/10/5

# 값을 조회 => getter
print(date.year, date.month, date.day)
> 2020 10 5

# 값을 대입 => setter 호출
date.day = 50
> 1~31 사이의 값을 넣으세요.

d = MyDate2(3000,30,50) # setter 호출
> 1~2023 사이의 값을 넣으세요.
> 1~12 사이의 값을 넣으세요.
> 1~31 사이의 값을 넣으세요.
```

`@을 이용하면 메소드를 변수처럼 사용 가능`

## [상속](#목차)

- 기존 클래스를 확장하여 새로운 클래스를 구현
    - 생성된 객체(instance)가 기존 클래스에 정의된 Attribute나 method를 사용할 수 있다.
- **기반(Base) 클래스, 상위(Super) 클래스, 부모(Parent) 클래스**
    - 상속하는 클래스
    - 상속하는 클래스에 비해 더 추상적인 클래스
- **파생(Derived) 클래스, 하위(Sub) 클래스, 자식(Child) 클래스**
    - 상속받는 클래스
- 상위 클래스와 하위 클래스는 계층관계를 이룬다.
    - 상위 클래스는 하위 클래스 객체의 타입이 된다.

```py
class Person: # 부모 클래스
    def go(self):
        print("간다.")

    def eat(self):
        print("먹는다.")

class Student(Person): # 자식 클래스
    def study(self):
        print("공부한다.")

class Teacher(Person):
    def teach(self):
        print("수업을 진행한다.")
```

```py
s = Student()
s.go()
s.eat()
s.study()
> 간다.
> 먹는다.
> 공부한다.

t = Teacher()
t.go()
t.eat()
t.teach()
> 간다.
> 먹는다.
> 수업을 진행한다.
```

```py
class Worker:
    def work(self):
        print("일을 한다.")

    def study(self):
        print("일을 배운다.")

class UniversityStudent(Student, Worker): # 다중 상속
    def drink(self):
        print("술 마신다.")
```

```py
us = UniversityStudent()
us.go()
us.study() # 이름이 같은 메소드는 왼쪽 먼저 실행
us.drink()
us.work()
> 간다.
> 공부한다.
> 술 마신다.
> 일을 한다.
```

study 메소드는 Student, Worker 둘 다 있음  
같은 이름, 서로 다른 메소드 -> 다중 상속의 문제  
왼쪽 위로 가면서 왼쪽 -> 오른쪽 순으로 찾는다.  

```py
UniversityStudent.mro() # 메소드 찾는 순서를 확인
> [__main__.UniversityStudent,
>  __main__.Student,
>  __main__.Person,
>  __main__.Worker,
>  object]
```

## [메소드 재정의](#목차)

- 상위 클래스 메소드의 구현부를 하위 클래스에서 다시 구현하는 것  
- 하위 클래스에서 overriding할 메소드의 선언문은 그대로 사용하고 그 구현부는 재구현한다.  

```python
super().메소드명() # 하위 클래스에서 상위 클래스의 instance를 반환해주는 함수

# self.xxxx: 같은 클래스의 메소드나 attribute(instance 변수) 호출
# super().xxxx: 부모클래스의 메소드나 attribute(부모객체의 attribute) 호출
```

```py
class UniversityStudent2(Student, Worker):
    def drink(self):
        print("술 마신다.")

    # method overriding
    def work(self): # 상위 클래스의 메소드를 오버라이딩
        print("아르바이르를 한다.")

    def eat(self):
        print("학교 식당에 간다.")
        # self.eat <- 무한루프 자기자신 eat 호출
        super().eat() # super() => 부모객체
```

```py
us2 = UniversityStudent2()
us2.work() # Worker 클래스를 바꿀 수는 없음
us2.eat()
> 아르바이르를 한다.
> 학교 식당에 간다.
> 먹는다.
```

```py
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def eat(self):
        print(f"{self.name} 이 먹는다.")

    def get_info(self):
        return f"{self.name}, {self.age}"

class Student(Person):
    def __init__(self, name, age, school_name):
        # name, age => Person의 속성
        # Person 객체를 초기화하도록 name과 age를 전달
        super().__init__(name, age)
        # 부모 객체의 __init__()을 호출 => 부모 클래스의 instance가 생성
        self.school_name = school_name

    def get_info(self): # method overriding 해서 구현
        info = super().get_info()
        return f"{info}, {self.school_name}"
```

```py
s = Student("홍길동", 17, "A고등학교")
s.name, s.age, s.school_name
> ('홍길동', 17, 'A고등학교')
s.eat()
> 홍길동 이 먹는다.
s.get_info()
> '홍길동, 17, A고등학교'
```

## [특수 메소드](#목차)

- 객체에 특정 기능들을 추가할 때 사용한다.
- 정의한 메소드와 그것을 호출하는 함수가 다르다.
    - ex) `__init__()` => **객체 생성할 때** 호출 된다.
- 메소드 명이 더블 언더스코어로 시작하고 끝난다. 
    - ex) `__init__(), __str__()`
- 매직 메소드(Magic Method) 또는 던더(DUNDER) 메소드

- **`__init__(self [, …])`**
    - Initializer
    - 객체 생성시 호출 된다.
    - 객체 생성시 Attribute의 값들을 초기화하는 것을 구현한다.
    - self 변수로 받은 instance에 Attribute를 설정한다.
- **`__call__(self [, …])`**
    - 객체를 함수처럼 호출하면 실행되는 메소드
        - 처리결과를 반환하도록 구현할 경우 `return value` 구문을 넣는다.
- **`__str__(self)`**
    - Instance(객체)의 Attribute들을 묶어서 문자열로 반환한다.
    - 내장 함수 **str(객체)**  호출할 때 이 메소드가 호출된다.
    - 객체에 `__str__()`가 없으면 `__repr__()` 을 호출
    - print() 함수는 값을 str() 에 넣어 문자열로 변환한다.

#### 연산자 재정의 특수 메소드
- 연산자의 피연산자로 객체를 사용하면 호출되는 메소드들
- 다항연산자일 경우 가장 왼쪽의 객체에 정의된 메소드가 호출된다.
    - `a + b` 일경우 a의 `__add__()` 가 호출된다.
- **비교 연산자**
    - **`__eq__(self, other)`** : self == other
        - == 로 객체의 내용을 비교할 때 정의 한다.
    - **`__lt__(self, other)`** : self < other, 
    - **`__gt__(self, other)`**: self > other
        - min()이나 max()에서 인수로 사용할 경우 정의해야 한다.
    - **`__le__(self, other)`**: self <= other
    - **`__ge__(self, other)`**: self >= other
    - **`__ne__(self, other)`**: self != other

- **산술 연산자**
    - **`__add__(self, other)`**: self + other
    - **`__sub__(self, other)`**: self - other
    - **`__mul__(self, other)`**: self * other
    - **`__truediv__(self, other)`**: self / other
    - **`__floordiv__(self, other)`**: self // other
    - **`__mod__(self, other)`**: self % other

### class변수, class 메소드
- **class변수**
    - (Instance가 아닌) 클래스 자체의 데이터
    - Attribute가 객체별로 생성된다면, class변수는 클래스당 하나가 생성된다.
    - 구현: class 블럭에 변수 선언.
- **class 메소드**
    - 클래스 변수를 처리하는 메소드
        - @classmethod 데코레이터를 붙인다.
        - 첫번째 매개변수로 클래스를 받는 변수를 선언한다. 이 변수를 이용해 클래스 변수나 다른 클래스 메소드를 호출 한다.

### static 메소드
- 클래스의 메소드로 클래스 변수와 상관없는 단순기능을 정의한다.
    - Caller 에서 받은 argument만 가지고 일하는 메소드를 구현한다.
    - @staticmethod 데코레이터를 붙인다.
    - Parameter에 대한 규칙은 없이 필요한 변수들만 선언한다.

### [목차로 돌아가기](#목차)
## [이전 페이지](../README.md)
