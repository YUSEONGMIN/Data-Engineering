### [전체 목차](../../README.md)
### [이전 페이지](../README.md)

# 4 일차
모듈, 패키지, 라이브러리 

## 목차

- [Module/Package](#modulepackage)


## [Module/Package](#목차)

### 모듈

- 독립적인 기능을 가지고 재사용 가능한 프로그램 단위
- 모듈은 재사용 가능한 함수, 클래스 등을 작성한 소스 파일
    - 함수나 클래스를 작성한 `.py` 스크립트 파일이 모듈이 된다.
- 모듈의 함수나 클래스들을 다른 python 프로그램에서 호출하여 사용할 수 있다.
    - 단 사용하기 위해서는 `import` 를 먼저 해야 한다.
- 이런 모듈들을 모아 놓으면 라이브러리가 된다.

- **모듈의 종류**
    - 표준 모듈
        - 파이썬에 내장된 모듈
    - 사용자 정의 모듈
        - 개발자가 재사용을 위해 직접 만든 모듈 
    - 3rd Party 모듈
        - 특정 개발업체나 개발자들이 만들어 배포하는 모듈
        - 사용자 정의 모듈도 배포되어 다른 곳에서 사용되면 3rd party 모듈이 된다.

### 패키지(라이브러리)
- 모듈들을 모아 놓은 것
- 물리적으로는 모듈 파일(.py)들을 모아놓은 디렉토리(폴더)가 패키지이다.  

- **Root Package**
    - 전체 모듈들을 담고 있는 최상위 패키지(디렉토리)
    - 패키지 내의 속한 패키지를 통칭 **sub package** 라고 한다.
    - Root package를 제외한 모든 package들은 다 sub package가 된다.

## import

## 함수, 클래스 정의란
1. 함수, 클래스를 구현한다.
2. 구현된 함수, 클래스를 파이썬 실행환경에 등록한다.
    - 등록하는 것은 메모리에 올리는(loading) 작업이다.
    - 메모리에 올리기 위해서는 구현된 것을 실행시켜서 파이썬 실행환경이 읽도록 해야 한다.
- 파이썬 실행환경에 등록된 함수와 클래스만 호출해서 사용할 수 있다.
## import 란
- 파이썬 모듈 파일에 정의된 변수, 함수, 클래스들을 사용하기 위해 **파이썬 실행환경에 등록하는 작업**을 말한다.
- 현재 프로그램 모듈의 것들이 아니라 **다른 모듈에 있는 것들은 사용하기 위해 import 작업을 먼저 해야 한다.**
- 모듈을 import 하면 모듈의 내용이 실행되면서 그 안에 구현된 변수, 함수, 클래스들이 파이썬 실행환경에 그 모듈 이름을 namespace로 하여 등록된다.


> - **namespace**
>    - 여러개의 객체(존재하는 무언가)를 하나로 묶어 주면서 구분자 역할을 하는 이름을 주는 것을 namespace라고 한다.
>    - namespace를 이용해 각 그룹들의 객체들을 구분할 수 있다. 그래서 같은 이름의 객체들을 사용할 수 있다.
>    - 파이썬에서는 모듈에 정의된 변수, 함수, 클래스 들을 실행환경에 등록할 때 모듈명을 namespace로 묶어서 등록한다.
>    - [위키백과 참고](https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%A6%84%EA%B3%B5%EA%B0%84)
## import 구문
- 기본구문
    - `[from 사용할 것의 경로] import 사용할 것 [as 별칭] [, 사용할 것 [as 별칭], ...]`
        - \[ \] : 생략 가능한 구문
    - 사용할 것
        - 모듈
        - 모듈안에 정의된 변수, 함수, 클래스
<b style='font-size:1.2em'> 1. 모듈 import</b>
```python
import 모듈   # 하나의 모듈 import.
import 모듈 as 별칭 # namespace의 이름을 모듈명이 아니라 별칭으로 지정한다.
import 모듈_1, 모듈_2 # 여러개 모듈 import.','를 구분자로 나열한다.
```
- 모듈을 import 하고 그 안에 함수, 클래스들을 사용할 때는 **모듈명이 namespace 의 이름이** 되므로 `모듈명.함수()`, `모듈명.Class` 구문으로 호출한다.
    - namespace의 이름은 **import 뒤에 지정한 이름으로 설정된다.**
- 별칭(Alias)를 주면 namespace의 이름으로 지정한 별칭을 사용한다.
- **예**
```python
import test_module
import my_module as mm
# test_module의 hello() 함수 호출시
test_module.hello()
# my_module은 mm 별칭을 지정했으므로 mm을 namespace로 사용한다.
p = mm.Person('홍길동', 30) # my_module의 Person 클래스 객체 생성
```
import A, B
from test import A, B
import A as a, B as b
<b style='font-size:1.2em'>2. 모듈내의 특정 항목만 import</b>
```python 
from 모듈 import 함수  # 함수/클래스가 있는 모듈과 함수를 분리해서 import한다.
from 모듈 import 클래스
from 모듈 import 함수_1, 함수_2, 클래스
from 모듈 import *   
```
- 모듈에 정의된 **일부 함수나 클래스만 사용할 경우** 개별적으로 import 할 수있다.
- `from 모듈 import 함수` 구문으로 import 하면 import한 **함수나 클래스들이 현재 실행중인 모듈의 namespace로 들어간다. 그래서 모듈명없이 바로 호출 할 수 있다.**
- `*`를 이용하면 그 모듈의 모든 함수/클래스들을 현재 실행중인 namespace에 추가해 사용할 수 있게 해준다. 이 방식은 **이름 충돌의 가능성이 있기때문에 추천되지 않는다.**
def plus():
    print("덧셈")
plus()
from my_package.calculator import * # 덮어질 수 있음
print(plus(1,1), divide(100,50))
<b style='font-size:1.2em'>3. 패키지에 속한 모듈 import</b>

```python
import 패키지명.모듈
from 패키지명 import 모듈
from 패키지명 import 모듈_1, 모듈_2
from 패키지명.모듈 import 함수
from 패키지명.모듈 import 클래스
from 패키지명.모듈 import 함수_1, 함수_2, 클래스
from Root패키지.Sub패키지1.Sub패키지2 import 모듈        # 패키지가 계층구조로 되있을 경우 `.` 으로 이용해 나열한다.
from Root패키지.Sub패키지1.Sub패키지2.모듈 import 함수
from Root패키지.Sub패키지1.Sub패키지2.모듈 import 클래스
```

- 패키지에 속한 모듈을 import 할 때는 **from 절에 패키지를 import 절에 모듈을** 설정한다.
- **import 가능한 것은 모듈, 변수, 함수, 클래스 들이다.**  <b style='color:red'>패키지는 import 할수 없다.</b>
    - **모듈 안의 변수, 함수, 클래스들을 import 할 때는 `from 모듈 import 함수, 변수, 클래스` 구문을 사용해야 한다.**
# my_module에 있는 함수/클래스 사용
# my_module을 import를 먼저 한다.
# my_module.py에서 확장자는 빼고 import
import my_module
# my_module의 greet 함수 호출
my_module.greet("홍길동")
p = my_module.Person("이순신", 30)
print(p)
import my_module as mm # mm => 별칭(alias)
txt = mm.greet("이순신")
print(txt)
p2 = mm.Person("강감찬", 10)
print(p2)
주피터노트북 기능
%%writefile .py # 새로 쓰기/덮어쓰기
%%writefile run.py
asd
asdasd
%load run.py # 불러오기
# %load run.py
asd
asdasd
%%writefile run.py
# run.py에서 my_module의 함수를 사용
import my_module as mm

print("__name__:", __name__)

print("덧셈:", c.plus(100, 200))

txt = mm.greet("홍길동")
print(txt)

p = mm.Person("이순신", 30)
print(p)

txt2 = mm.greet(p.name)
print(txt2)
%%writefile run2.py
# 모듈 안의 특정 함수/클래스만 import
# from 모듈명 import import 대상
from my_module import greet

txt = greet("홍길동")
print(txt)
from my_module import Person

p = Person("유관순", 30)
print(p)
%%writefile my_package/calculator.py

def plus(num1, num2):
    return num1 + num2

def minus(num1, num2):
    return num1 - num2

def multipy(num1, num2):
    return num1 * num2

def divide(num1, num2):
    return num1 / num2
import my_package.calculator
my_package.calculator.plus(1,2)
import my_package.calculator as calc
calc.plus(100,200)
# import 모듈/모듈안에 함수
from my_package import calculator # as calc
calculator.minus(10,5)
모듈 안에 함수/클래스 import -> from 모듈 import 함수
import 모듈.함수 (X)
from my_package.calculator import divide
## import 된 모듈 찾는 경로 및 PYTHONPATH

- `import 모듈` 구문을 사용하면 파이썬 실행 환경은 모듈을 다음 경로에서 찾는다.
    1. 현재 실행중인 모듈(import 구문을 사용한 모듈)이 있는 경로
    2. 파이썬 실행환경에 등록된 경로
- 모듈을 찾는 순서는 다음에서 확인할 수 있다.
```python
import sys      # 표준모듈 sys
print(sys.path) # 모듈을 찾는 경로를 저장한 list
```
- 위의 경로 이외에 파이썬 모듈이 있을 경우 PYTHONPATH 환경변수에 그 디렉토리 경로를 등록한다.
    1. sys.path 에 추가한다. (사용할 때 마다 추가해야 한다.)
    2. 운영체제 환경변수에 등록한다. (한번만 하면된다.)
import sys
from pprint import pprint # 자료구조를 보기좋게 출력하는 함수

pprint(sys.path) # 모듈을 찾는 경로, 그 순서
%%writefile "C:\source\test_module.py"
def hello_world():
    print("Hello World!")
sys.path.append(r"C:\source") # import 할 대상이 있는 파일경로를 추가
sys.path
import test_module as tm
tm.hello_world()
# 메인 모듈(Main Module)과 하위 모듈(Sub Module)

- **메인 모듈**
    - 현재 실행하고 있는 모듈
        - `python 모듈.py` 로 실행된 모듈을 말한다.
    - application 의 main logic을 처리한다.
- **하위 모듈 (Sub module)**
    - 메인 모듈에서 import 되어 실행되는 모듈
    - 모듈을 import하면 그 모듈을 실행 시킨다. 이때 모듈에 있는 실행코드들도 같이 실행된다. 이것을 방지 하기 위해 모듈이 메인 모듈로 실행되는지 하위 모듈로 실행되는지 확인이 필요하다.
- <b>`__name__`</b> 내장 전역변수
    - 실행 중인 모듈명을 저장하는 내장 전역변수
    - **메인 모듈은 '\_\_main\_\_'** 을 **하위 모듈은 모듈명(파일명)** 이 저장된다.
    - 모듈이 메인 모듈로 시작하는지 여부 확인 할 때 사용한다.
    
```python
if __name__ == '__main__':
    # 메인모듈일 때만 실행할 코드 블록
```
run.py 안에 import my_module -> my_module은 서브 모듈이라서 __name__은 my_module. 메인은 run
!python run.py
!python my_module.py
# 3rd party library 설치

- 기능을 모아 놓은 것이 **모듈(module)** 이고 모듈을 모아 놓은 것이 **패키지** 이고 그런 패키지들을 모아서 놓은 것이 **Library** 이다.
- **Library** 는 범용적으로 사용할 수있는 기능들을 구현해서 배포한 것을 말한다. 파이썬에서는 라이브러리를 패키지라고도 한다.
- Library는 누구든 만들어서 배포(제공)할 수있다.
    - **1st party library:** 파이썬 실행 환경 설치시 내장되어 있는 library
    - **2nd party library:** Application을 만들면서 필요에 따가 정의한 library (내가 만든 라이브러리)
    - **3rd party library:** 개인이나 회사 또는 단체에서 만들어 배포한 library.
- Python은 3rd party library 생태계가 잘 이루어져 있다.
    - 파이썬은 라이브러리 저장소(repository)를 이용해 라이브러리 작성자들과 사용자들을 연결해 배포와 사용을 쉽게 할 수 있도록 한다.
    - **PyPI:** 파이썬 공식 라이브러리 저장소
        - https://pypi.org/ : 라이브러리 검색 사이트
        - pip tool을 이용해 라이브러리를 관리한다.
    - **Conda Repository:** Anaconda 에서 제공하는 라이브러리 저장소
        - https://anaconda.org/anaconda/repo : 패키지 검색 사이트
        - conda tool 을 이용해 라이브러리를 관리한다.
### PIP 주요 명령어
- pip는 python runtime 설치하면 같이 설치되는 **라이브러리 관리 툴**이다.
- `pip --help`
- `pip install 라이브러리[==version]` 
    - Library를 설치한다.
    - version을 지정하면 그 버전으로 지정하지 않으면 최신버전을 설치한다.
    - upgrade나 downgrade는 진행하지 않는다. (이미 설치 된 library가 있으면 다시 설치 하지 않는다.)
    - 관리자 권한일 경우 설치되는 library가 있다. 이 경우 **--user** 옵션을 지정한다.
- `pip install --upgrade 라이브러리[==version]`, \-U \-\-upgrade
    - Library를 upgrade 또는 downgrade한다.
    - Library가 없으면 설치한다.
    - 이미 설치된 Library가 지정한 version과 다르면 다시 설치한다. (version을 생략하면 최신버전)
- `pip install --requirement 파일경로`,  \-r, \-\-requirement
    - 파일경로의 text 파일에 설치할 library이름과 버전을 작성한다. 그리고 작성된 library들을 한번에 설치한다.
- `pip freeze > 파일명.txt`
    - 현재 설치된 library들을 \-\-requirement로 설치할 수 있도록 text 파일에 작성해 준다. 관례적으로 파일명은 **requirements.txt** 로 한다.
- `pip uninstall 패키지명`
    - Library를 local 컴퓨터에서 삭제한다.
- `pip list`: 설치된 모든 library 목록을 출력한다.
- `pip show 라이브러리`
    - 지정한 library의 정보를 출력한다.

### [목차로 돌아가기](#목차)
## [이전 페이지](../README.md)
